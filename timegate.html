<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Time Gate</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --maxw: 720px; }
    body { font-family: Arial, sans-serif; display:flex; min-height:100vh; align-items:center; justify-content:center; padding:24px; background:#0f172a; color:#e2e8f0; }
    .card { width:100%; max-width:var(--maxw); background:#111827; border:1px solid #1f2937; border-radius:16px; padding:24px; box-shadow: 0 10px 30px rgba(0,0,0,.35); }
    h1 { margin:0 0 12px; font-size:28px; }
    p { margin:8px 0; line-height:1.5; }
    .muted { color:#9ca3af; }
    .count { font-variant-numeric: tabular-nums; font-weight:600; }
    .bar { height:10px; background:#1f2937; border-radius:999px; overflow:hidden; margin-top:8px; }
    .bar > div { height:100%; width:100%; background:#3b82f6; transition: width 0.25s linear; }
    .hidden { display:none; }
    .btn { margin-top:16px; padding:10px 14px; border-radius:10px; border:1px solid #334155; background:#0b2a50; color:#e2e8f0; cursor:pointer; }
    .btn:hover { background:#0a2547; }
    .row { display:flex; gap:10px; align-items:center; justify-content:space-between; }
    code { background:#0b1220; padding:2px 6px; border-radius:6px; border:1px solid #1f2937; }
  </style>
</head>
<body>
  <div class="card">
    <h1>Time Gate</h1>
    <p id="status" class="muted">Checking access…</p>

    <div id="lock" class="hidden">
      <p>Access locked. Please wait <span class="count" id="countdown">--:--</span> before trying again.</p>
      <div class="bar"><div id="barfill" style="width:100%"></div></div>
      <p class="muted" id="hint"></p>
      <button id="tryAgain" class="btn">Try again now</button>
    </div>

    <div id="resetInfo" class="hidden" style="margin-top:16px;">
      <div class="row">
        <p class="muted">Full reset in: <span class="count" id="resetCountdown">--:--</span></p>
        <div class="bar" style="flex:1"><div id="resetBar" style="width:100%"></div></div>
      </div>
      <p class="muted" style="margin-top:6px;">When this reaches 0, all <code>timegate_*</code> data clears and behavior resets as brand new.</p>
    </div>
  </div>

<script>
// ===== CONFIGURATION =====
// 1) Per-phase lock window (used between unlocking options)
const TIMER_DURATION = 2 * 60 * 1000; // 2 minutes (e.g., 12 * 60 * 60 * 1000 for 12 hours)
// 2) Global reset window — after this time elapses, ALL time gate data is cleared automatically
const RESET_DURATION = 10 * 60 * 1000; // 10 minutes initial. Change as needed.

// ===== FINAL DESTINATIONS =====
const finalLinks = {
  "gateoption1": "https://ritchierodriguez-commits.github.io/Juliana-Token-Redemption-Site/Option1BJCOL.html",
  "gateoption2": "https://ritchierodriguez-commits.github.io/Juliana-Token-Redemption-Site/Option2OILMASSAGECOL.html",
  "gateoption3": "https://ritchierodriguez-commits.github.io/Juliana-Token-Redemption-Site/ritchievul.html"
};

// ===== STORAGE KEYS =====
const ACCESS_PREFIX   = "timegate_accessed_";
const TIMER_KEY       = "timegate_timer_start";
const RESET_START_KEY = "timegate_reset_start";

// ===== HELPERS =====
function getSourceGate() {
  const url = new URL(window.location.href);
  const qp = url.searchParams.get("from");
  if (qp && finalLinks[qp]) return qp;
  const ref = document.referrer || "";
  if (ref.includes("gateoption1")) return "gateoption1";
  if (ref.includes("gateoption2")) return "gateoption2";
  if (ref.includes("gateoption3")) return "gateoption3";
  return null;
}

function setUnlocked(g) { localStorage.setItem(ACCESS_PREFIX + g, "true"); }
function isUnlocked(g) { return localStorage.getItem(ACCESS_PREFIX + g) === "true"; }
function unlockedCount() { return ["gateoption1","gateoption2","gateoption3"].reduce((n,g)=> n + (isUnlocked(g)?1:0), 0); }
function startTimer()   { localStorage.setItem(TIMER_KEY, String(Date.now())); }
function getStart()     { const v = localStorage.getItem(TIMER_KEY); return v ? parseInt(v,10) : null; }
function clearTimer()   { localStorage.removeItem(TIMER_KEY); }

function ensureResetStart() {
  if (!localStorage.getItem(RESET_START_KEY)) {
    localStorage.setItem(RESET_START_KEY, String(Date.now()));
  }
}
function getResetStart() {
  const v = localStorage.getItem(RESET_START_KEY);
  return v ? parseInt(v, 10) : null;
}

function formatMMSS(ms) {
  if (ms < 0) ms = 0;
  const total = Math.ceil(ms / 1000);
  const m = Math.floor(total / 60);
  const s = total % 60;
  return `${m}:${s.toString().padStart(2, "0")}`;
}

function clearAllTimeGateData() {
  const keys = [];
  for (let i = 0; i < localStorage.length; i++) {
    const k = localStorage.key(i);
    if (k && k.startsWith("timegate_")) keys.push(k);
  }
  keys.forEach(k => localStorage.removeItem(k));
}

// ===== UI =====
const statusEl = document.getElementById("status");
const lockEl = document.getElementById("lock");
const countdownEl = document.getElementById("countdown");
const barfillEl = document.getElementById("barfill");
const tryAgainBtn = document.getElementById("tryAgain");
const hintEl = document.getElementById("hint");
const resetInfoEl = document.getElementById("resetInfo");
const resetCountdownEl = document.getElementById("resetCountdown");
const resetBarEl = document.getElementById("resetBar");

function showLock(remaining, total) {
  statusEl.textContent = "Access currently locked for this option.";
  lockEl.classList.remove("hidden");
  countdownEl.textContent = formatMMSS(remaining);
  const pct = Math.max(0, Math.min(100, (remaining / total) * 100));
  barfillEl.style.width = pct + "%";
  hintEl.textContent = "Timer window blocks unlocking new options. Previously unlocked options remain accessible.";
}
tryAgainBtn.addEventListener("click", () => window.location.reload());

function updateResetUI() {
  const rs = getResetStart();
  if (!rs) return;
  const elapsed = Date.now() - rs;
  const remaining = RESET_DURATION - elapsed;
  if (remaining <= 0) return;
  resetInfoEl.classList.remove("hidden");
  resetCountdownEl.textContent = formatMMSS(remaining);
  const pct = Math.max(0, Math.min(100, (remaining / RESET_DURATION) * 100));
  resetBarEl.style.width = pct + "%";
}

// ===== GLOBAL RESET CHECK (runs on every visit) =====
(function globalResetCheck() {
  const rs = getResetStart();
  if (rs) {
    const elapsed = Date.now() - rs;
    if (elapsed >= RESET_DURATION) {
      clearAllTimeGateData();
      // After clearing, immediately set a new reset window starting now
      localStorage.setItem(RESET_START_KEY, String(Date.now()));
      // Reload page so logic runs from a clean slate
      window.location.replace(window.location.href.split('#')[0]);
      return;
    }
  }
})();

// Start / reveal the reset countdown bar
ensureResetStart();
updateResetUI();
setInterval(updateResetUI, 1000);

// ===== MAIN LOGIC =====
(function main() {
  const gate = getSourceGate();

  if (!gate) {
    statusEl.textContent = "Access denied: Unknown source. (Missing referrer or ?from=gateoptionN)";
    hintEl.textContent = "Tip: Link to this page like time-gate.html?from=gateoption1";
    lockEl.classList.remove("hidden");
    tryAgainBtn.classList.add("hidden");
    return;
  }

  // Already unlocked for this gate -> allow immediately
  if (isUnlocked(gate)) {
    statusEl.textContent = "Unlocked — redirecting…";
    window.location.replace(finalLinks[gate]);
    return;
  }

  const count = unlockedCount();
  const start = getStart();
  const now = Date.now();
  const elapsed = start ? (now - start) : null;

  if (count === 0) {
    setUnlocked(gate);
    startTimer();
    statusEl.textContent = "First option unlocked — redirecting…";
    window.location.replace(finalLinks[gate]);
    return;
  }

  if (count === 1) {
    if (elapsed !== null && elapsed >= TIMER_DURATION) {
      setUnlocked(gate);
      startTimer(); // restart timer for phase 2 -> phase 3
      statusEl.textContent = "Second option unlocked — redirecting…";
      window.location.replace(finalLinks[gate]);
    } else {
      const remaining = TIMER_DURATION - (elapsed ?? 0);
      showLock(remaining, TIMER_DURATION);
      const iv = setInterval(() => {
        const st = getStart();
        if (!st) { clearInterval(iv); window.location.reload(); return; }
        const rem = TIMER_DURATION - (Date.now() - st);
        if (rem <= 0) { clearInterval(iv); window.location.reload(); return; }
        showLock(rem, TIMER_DURATION);
      }, 1000);
    }
    return;
  }

  if (count === 2) {
    if (elapsed !== null && elapsed >= TIMER_DURATION) {
      setUnlocked(gate);
      clearTimer();
      statusEl.textContent = "Third option unlocked — redirecting…";
      window.location.replace(finalLinks[gate]);
    } else {
      const remaining = TIMER_DURATION - (elapsed ?? 0);
      showLock(remaining, TIMER_DURATION);
      const iv = setInterval(() => {
        const st = getStart();
        if (!st) { clearInterval(iv); window.location.reload(); return; }
        const rem = TIMER_DURATION - (Date.now() - st);
        if (rem <= 0) { clearInterval(iv); window.location.reload(); return; }
        showLock(rem, TIMER_DURATION);
      }, 1000);
    }
    return;
  }

  statusEl.textContent = "All options unlocked — redirecting…";
  window.location.replace(finalLinks[gate]);
})();
</script>
</body>
</html>
